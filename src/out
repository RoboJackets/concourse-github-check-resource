#!/usr/bin/env python3

from json import dumps, loads, load
from sys import stdin, stderr, argv
from subprocess import run
from os import getenv, path, listdir
from datetime import datetime
from requests import patch, post


def timestamp_for_github():
    return datetime.now().astimezone().replace(microsecond=0).isoformat()


def parse_yamllint_annotations(source_path):
    annotations=[]
    for source_file in listdir(source_path):
        note_levels={
            "warning": "warning",
            "error": "failure"
        }
        regex = r"(.*)[:](.*)[:].*[:] [[](warning|error)[]] (.*)"

        with open(source_file, "r")
            for line in file:
                note_parts = re.split(regex, test_str)
                note = {
                    "path": note_parts[1],
                    "start_line": note_parts[2],
                    "end_line": note_parts[2],
                    "annotation_level": note_levels[note_parts[3]],
                    "message": note_parts[4]
                }
                annotations.append(note)
    return annotations

required_source_fields = ("repository", "token", "check_name", "resource_name")
optional_source_fields = ("annotations_format", "annotations_location", "debug")
conclusion_options = ("success", "failure", "neutral", "cancelled", "skipped", "timed_out", "action_required")

timestamp = timestamp_for_github()

assert len(argv) == 2

input_directory = argv[1]

assert path.exists(input_directory)
assert path.isdir(input_directory)

concourse_input = loads(stdin.read())

assert isinstance(concourse_input, dict)
assert "source" in concourse_input, "Missing required `source` fields"
assert isinstance(concourse_input["source"], dict), "`source` must be a dict, check pipeline configuration"

for source_field in required_source_fields:
    assert source_field in concourse_input["source"], f"Missing required field `{source_field}`in `source`"

for source_field in concourse_input["source"]:
    assert source_field in required_source_fields or source_field in optional_source_fields, f"Unexpected field `{source_field}` passed in `source`"

repository = path.join(input_directory, concourse_input['source']['repository'])

assert path.exists(repository)
assert path.isdir(repository)

if len(listdir(input_directory)) > 2:
    print("To improve performance, you may want to manually configure the inputs to this step. See the documentation for more information.", file=stderr)

git_rev_parse_output = run(['git', '-C', repository, 'rev-parse', 'HEAD'], text=True, capture_output=True)
assert git_rev_parse_output.returncode == 0

git_remote_output = run(['git', '-C', repository, 'remote', '--verbose'], text=True, capture_output=True)
assert git_remote_output.returncode == 0

remote = git_remote_output.stdout.strip().split("\n")[0].split("\t")[1].split("/")
host = remote[2]
api_base_url = 'https://' + ('api.github.com' if host == 'github.com' else host + '/api/v3')
owner = remote[3]
repo = remote[4].split(" ")[0]
head_sha = git_rev_parse_output.stdout.strip()
name = concourse_input['source']['check_name']
details_url = getenv('ATC_EXTERNAL_URL') + '/teams/' + getenv('BUILD_TEAM_NAME') + '/pipelines/' + getenv('BUILD_PIPELINE_NAME') + '/jobs/' + getenv('BUILD_JOB_NAME') + '/builds/' + getenv('BUILD_NAME')

state_file_path = path.join(input_directory, concourse_input['source']['resource_name'], "state.json")

if path.exists(state_file_path):
    assert path.isfile(state_file_path)

    with open(state_file_path, "r") as state_file:
        state = load(state_file)

    assert isinstance(state, dict)
    assert isinstance(state["id"], str)

    check_id = state["id"]

    assert "params" in concourse_input, "`params` required to update an existing check"
    params = concourse_input["params"]
    assert isinstance(params, dict), "`params` must be a dict, check pipeline configuration"

    assert "conclusion" in params, "`conclusion` required in `params` to update an existing check"

    conclusion = params['conclusion']

    assert conclusion in conclusion_options, "Invalid `conclusion` specified - refer to the GitHub API documentation for possible values"

    data = {
        'conclusion': conclusion,
        'completed_at': timestamp,
    }

    if 'title' in params and 'summary' in params:
        data['output'] = {
            'title': params["title"],
            'summary': params["summary"],
        }
    else:
        if conclusion == 'cancelled':
            data['output'] = {
                'title': 'Task cancelled by user',
                'summary': 'Re-run the job within Concourse.',
            }
        if conclusion == 'action_required':
            data['output'] = {
                'title': 'Error running task',
                'summary': 'Review the output within Concourse.',
            }

    if "annotations_format" in concourse_input["source"]:
        annotations_format = concourse_input["source"]["annotations_format"]
        assert isinstance(annotations_format, str)
        if "annotations_location" in concourse_input["source"]:
            annotations_location = concourse_input["source"]["annotations_format"]
        else:
            annotations_location = annotations_format
        annotations_path = path.join(input_directory, annotations_location)
        assert path.exists(annotations_path)
        assert path.isdir(annotations_path)

        if len(listdir(annotations_path)) == 0:
            print("No input files found for annotations.", file=stderr)
        else:
            if annotations_format == "yamllint":
                data["output"] = parse_yamllint_annotations(annotations_path)
            else:
                print(f"Invalid annotations format `{annotations_format}` passed.", file=stderr)
                exit(1)

    headers = {
        'Authorization': 'Bearer ' + concourse_input['source']['token'],
        'User-Agent': 'concourse-github-check-resource',
        'Accept': 'application/vnd.github.antiope-preview+json'
    }

    response = patch(f"{api_base_url}/repos/{owner}/{repo}/check-runs/{check_id}", json=data, headers=headers)
    assert response.status_code == 200, f"Got unexpected response code {response.status_code} from GitHub: {response.json()}"

    url = response.json()['url']
    html_url = response.json()['html_url']

    print(
        dumps(
            {
                'version': {
                    'id': check_id
                },
                'metadata': [
                    {
                        'name': 'url',
                        'value': url
                    },
                    {
                        'name': 'html_url',
                        'value': html_url
                    }
                ]
            }
        )
    )
else:
    data = {
        'name': name,
        'head_sha': head_sha,
        'details_url': details_url,
        'status': 'in_progress',
        'started_at': timestamp_for_github(),
    }

    headers = {
        'Authorization': 'Bearer ' + concourse_input['source']['token'],
        'User-Agent': 'concourse-github-check-resource',
        'Accept': 'application/vnd.github.antiope-preview+json'
    }

    response = post(f"{api_base_url}/repos/{owner}/{repo}/check-runs", json=data, headers=headers)
    assert response.status_code == 201, f"Got unexpected response code {response.status_code} from GitHub: {response.json()}"

    json = response.json()

    check_id = json["id"]
    url = json['url']
    html_url = json['html_url']

    print(
        dumps(
            {
                'version': {
                    'id': str(check_id)
                },
                'metadata': [
                    {
                        'name': 'url',
                        'value': url
                    },
                    {
                        'name': 'html_url',
                        'value': html_url
                    }
                ]
            }
        )
    )
